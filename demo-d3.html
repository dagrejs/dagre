<!doctype html>

<meta charset="utf-8">
<title>Dagre Test Page</title>

<h2>Graph Visualization</h2>

<svg width=0 height=0>
  <defs>
    <marker id="arrowhead"
            viewBox="0 0 10 10"
            refX="8"
            refY="5"
            markerUnits="strokeWidth"
            markerWidth="8"
            markerHeight="5"
            orient="auto"
            style="fill: #333">
      <path d="M 0 0 L 10 5 L 0 10 z"></path>
    </marker>
  </defs>
</svg>

<script src="http://d3js.org/d3.v2.min.js"></script>
<script src="dagre.js"></script>

<style>
.node rect {
  stroke-width: 1.5px;
  stroke: #333;
  fill: #fff;
}

#node-CLOSED rect {
  stroke-width: 3px;
  fill: #f88;
}

.node text {
  font: 300 16px "Helvetica Neue";
}

.node:hover {
	cursor: pointer;
	opacity: 0.4;
}

path.edge {
  fill: none;
  stroke: #333;
  stroke-width: 1.5px;
}

.edge:hover {
	cursor: pointer;
	opacity: 0.4;
}
</style>

<script>
  var nodePadding = 10;
</script>

<script>
  // Source RFC 793
  var transitions = [
    { source: "CLOSED", target: "LISTEN" },
    { source: "LISTEN", target: "SYN RCVD" },
    { source: "LISTEN", target: "SYN SENT" },
    { source: "LISTEN", target: "CLOSED" },
    { source: "SYN RCVD", target: "FINWAIT-1" },
    { source: "SYN RCVD", target: "ESTAB" },
    { source: "SYN SENT", target: "SYN RCVD" },
    { source: "SYN SENT", target: "ESTAB" },
    { source: "SYN SENT", target: "CLOSED" },
    { source: "ESTAB", target: "FINWAIT-1" },
    { source: "ESTAB", target: "CLOSE WAIT" },
    { source: "FINWAIT-1", target: "FINWAIT-2" },
    { source: "FINWAIT-1", target: "CLOSING" },
    { source: "CLOSE WAIT", target: "LAST-ACK" },
    { source: "FINWAIT-2", target: "TIME WAIT" },
    { source: "CLOSING", target: "TIME WAIT" },
    { source: "LAST-ACK", target: "CLOSED" },
    { source: "TIME WAIT", target: "CLOSED" },
  ];

  function spline(points) {
    return d3.svg.line()
      .x(function(d) { return d.x; })
      .y(function(d) { return d.y; })
      .interpolate("linear")
      (points);
  }

  // Get the data in the right form
  var stateKeys = {};
  transitions.forEach(function(d) {
    stateKeys[d.source] = { label: d.source };
    stateKeys[d.target] = { label: d.target };
  });
  var states = d3.values(stateKeys);
  transitions.forEach(function(d) {
    d.source = stateKeys[d.source];
    d.target = stateKeys[d.target];
  });

  // Now start laying things out
  var svg = d3.select("svg");
  var svgGroup = svg.append("g").attr("transform", "translate(5, 5)");

  // `nodes` is center positioned for easy layout later
  var nodes = svgGroup
    .selectAll("g .node")
    .data(states)
    .enter()
      .append("g")
      .attr("class", "node")
      .attr("id", function(d) { return "node-" + d.label });

  var edges = svgGroup
    .selectAll("path .edge")
    .data(transitions)
    .enter()
      .append("path")
      .attr("class", "edge")
      .attr("marker-end", "url(#arrowhead)");

  // Append rectangles to the nodes. We do this before laying out the text
  // because we want the text above the rectangle.
  var rects = nodes.append("rect");

  // Append text
  var labels = nodes
    .append("text")
      .attr("text-anchor", "middle")
      .attr("x", 0);

  labels
    .append("tspan")
    .attr("x", 0)
    .attr("dy", "1em")
    .text(function(d) { return d.label; });

  // We need width and height for layout.
  labels.each(function(d) {
    var bbox = this.getBBox();
    d.bbox = bbox;
    d.width = bbox.width + 2 * nodePadding;
    d.height = bbox.height + 2 * nodePadding;
  });

  rects
    .attr("x", function(d) { return -(d.bbox.width / 2 + nodePadding); })
    .attr("y", function(d) { return -(d.bbox.height / 2 + nodePadding); })
    .attr("width", function(d) { return d.width; })
    .attr("height", function(d) { return d.height; });

  labels
    .attr("x", function(d) { return -d.bbox.width / 2; })
    .attr("y", function(d) { return -d.bbox.height / 2; });

	// Create the layout and get the graph
  var graph = dagre.layout()
    .nodeSep(50)
    .edgeSep(10)
    .rankSep(50)
    .nodes(states)
    .edges(transitions)
    .debugLevel(1)
	.run()
	.graph();

	nodes.attr("transform", function(d) { return 'translate('+ d.dagre.x +','+ d.dagre.y +')'; });

	edges
		// Set the id. of the SVG element to have access to it later
		.attr('id', function(e) { return e.dagre.id; })
		.attr("d", function(e) {
			var points = e.dagre.points;
			var source = dagre.util.intersectRect(e.source.dagre, points.length > 0 ? points[0] : e.source.dagre);
			var target = dagre.util.intersectRect(e.target.dagre, points.length > 0 ? points[points.length - 1] : e.source.dagre);
			points.unshift(source);
			points.push(target);
			return spline(points);
		});

	// Resize the SVG element
	var svgBBox = svg.node().getBBox();
	svg.attr("width", svgBBox.width + 10);
	svg.attr("height", svgBBox.height + 10);

	// Drag handlers
	var nodeDrag = d3.behavior.drag()
		// Set the right origin (based on the Dagre layout or the current position)
		.origin(function(d) { return d.pos ? {x: d.pos.x, y: d.pos.y} : {x: d.dagre.x, y: d.dagre.y}; })
		.on('drag', function (d, i) {
			// Store the current node position without overwriting the original Dagre value
			d.pos || (d.pos = {x: d.dagre.x, y: d.dagre.y});

			// The node must be inside the SVG area
			d.pos.x = Math.max(d.width / 2, Math.min(svgBBox.width - d.width / 2, d3.event.x));
			d.pos.y = Math.max(d.height / 2, Math.min(svgBBox.height - d.height / 2, d3.event.y));
			d3.select(this).attr('transform', 'translate('+ d.pos.x +','+ d.pos.y +')');

			// Edges position (inside SVG area)
			graph.inEdges(d.dagre.id).forEach(function(edgeId) {
				d3.select('#'+ edgeId).attr('d', function(edge) {
					for (var i = 1, p = edge.dagre.points; i < p.length; i++)
						p[i] = {x: p[i].x + d3.event.dx, y: p[i].y + d3.event.dy};

					return spline(p);
				});
			});
			graph.outEdges(d.dagre.id).forEach(function(edgeId) {
				d3.select('#'+ edgeId).attr('d', function(edge) {
					for (var i = 0, p = edge.dagre.points; i < p.length - 1; i++)
						p[i] = {x: p[i].x + d3.event.dx, y: p[i].y + d3.event.dy};

					return spline(p);
				});
			});
		});

	var edgeDrag = d3.behavior.drag()
		.on('drag', function (d, i) {
			d3.select(this).attr('d', function() {
				for (var i = 1, p= d.dagre.points; i < p.length - 1; i++)
					p[i] = {
						x: Math.max(0, Math.min(svgBBox.width, p[i].x + d3.event.dx)),
						y: Math.max(0, Math.min(svgBBox.height, p[i].y + d3.event.dy))
					};

				return spline(p);
			});
		});

	nodes.call(nodeDrag);
	edges.call(edgeDrag);
</script>
